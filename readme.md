Включает "современный" режим
"use strict"

Добавить код из файла
<script src="code.js"></script>

Оповещение для каждого элемента массива
[].forEach(alert)

Возвращает число по основанию 2 - 36 в виде строки
(7).toString(2) // "111"

Математическое округление числа до n знака в виде строки
.toFixed(n)

Проверка на NaN и Infinity
isNaN("word") // true
isFinite(Infinity) // false
Object.is(NaN, NaN) // true

Ввод строки
prompt(, ) // первый аргумент - ввод текста, второй - начальный текст

Ввод согласия
confirm()

Считывание чисел со строки (если чисел нет, то NaN)
parseInt(, ) // целое число из строки до символа (второй аргумент для систем счисления)
parseFloat() // десятичное число из строки до символа

Встраивание переменной n в строку ``
`${n}`

Стрелочная функция
() => // не имеет this, arguments, new

Замена подстроки
.replace(, )

Присваивание
[, , ] = [, ] // записывает элементы в переменные, не уничтожая массив (ненужные элементы отбрасываются через запятую)
[, ...] = [, , ] // через ... присваивается всё оставшееся

Массивы
.map(() => ...) // изменение элементов поступившего массива
... // превращает массив в список аргументов

Функции // могут быть добавлены новые свойства
new Function() // создание функции из строки
(...) // остаточный аргумент помещает аргументы в массив
.name // преобразует имя функции в строку
.length // количество аргументов
.call() // первый аргумент конкретно указывает this для переданого объекта
.apply() // тоже, что и .call(), но второй аргумент - массив
.bind() // фиксирует this по контексту объекта, при отсутствии this пишется null
async function // асинхронная функция, возвращает промис
await // ожидает выполнение промиса в асинхронной функции, работает с Promise.all()

Функция-генератор
function* ...() {yield ...; } // функция-генератор создаёт объект "генератор"
.next() // выполняет текущий yield, возвращая объект {value: ..., done: false} (если функция выполнилась - true)
yield* // передача выполнения другому генератору

Объекты
[name] // обращение по имени
... in ... // проверка существования имени
for (let ... in ...) // перебор объекта
.assign() // копирование свойств объекта, совпадающие имена перезаписываются
.cloneDeep() // глубокое копирование
[Symbol.toPrimitive](hint) {return hint == "string" ? this.name : this.surname;} // при преобразовании объекта возвращает значение хинта
toString() // указания при преобразовании в строку
valueOf() // указания при преобразовании в число
Array.from() // делает из объекта массив
Object.entries() // делает из объекта массив ключ/значение (для Мар)
Object.fromEntries() // делает из массива ключ/значение объект
Object.keys() // возвращает массив ключей
Object.values() // возвращает массив значений
Object.entries() // возвращает массив пар ключ/значение
let {, :} // присваивание ключам слева значений объекта справа, через двоеточие ключ:новый ключ
let {, ...} // через ... присваивается всё оставшееся
JSON.stringify() // преобразование объекта/массива в строку
JSON.parse() // преобразование строки в объект/массив
toJSON() // изменение преобразования в строке JSON
Object.getOwnPropertyDescriptor(, ) // полная информация о свойстве объекта (объект, ключ)
Object.defineProperty(, "", {}) // изменить свойство (объект, ключ, свойство (writable - записуемый, enumerable - итерируемый, configurable - удаляемый))
Object.defineProperties(, {{}, {}}) // изменить сразу несколько свойств (объект, свойства)
Object.getOwnPropertyDescriptors() // получить все свойства объекта
Object.defineProperties(, Object.getOwnPropertyDescriptors()) // копирование объекта вместе со свойствами
Object.preventExtensions() // запрет на добавление свойств объекта
Object.seal() // запрет на добавление/удаление свойств объекта (везде configurable: false)
Object.freeze() // запрет на добавление/удаление/изменение свойств объекта (везде configurable: false, writable: false)
Object.isExtensible() // добавление свойств разрешено - true
Object.isSealed() // добавление/удаление свойств запрещено (везде configurable: false)  - true
Object.isFrozen() // добавление/удаление/изменение свойств запрещено (везде configurable: false, writable: false)  - true
get () // установить чтение объекта
set () // установить запись объекта (есть аргумент)
__proto__ // наследование свойства объекта (может быть объектом или null), переопределение работает на объект-наследник (устарело)
.hasOwnProperty() // возвращает true, если свойство объекта его личное
.prototype // наследование метода (или объекта при создании через функцию new)
Object.create(, {}) // создаёт объект со свойствами наследуемого
Object.getPrototypeOf() // возвращает свойство прототипа объекта
Object.setPrototypeOf(, ) // устанавливает свойство прототипа объекта (объект, прототип)
let ... = Object.create(Object.getPrototypeOf(), Object.getOwnPropertyDescriptors()) // точная копия объекта

Классы // методы неперечислимы, включён use strict
constructor() // конструктор класса, при наследовании в нём вызывается super
есть get () и set ()
class ... extends ... // наследование классом другого класса или чего-то ещё
super // наследует метод класса для переопределения
static // используется для методов класса в целом
... instanceof ... // проверка принадлежности классов или функций друг к другу, учитывая наследование (возвращает true)
.isPrototypeOf() // проверка принадлежности классов друг к другу, учитывая наследование (возвращает true)
Object.assign(.prototype, ) // копирование в класс
.trigger(, ) // создаёт событие ключ/свойство
.on(, ) // обрабатывает событие ключ/свойство
.off(, ) // убирает событие ключ/свойство
this.name = this.constructor.name // присвоить классу его имя

Map
new Map() // создание коллекции
.set(, ) // запись ключ/значение
.get() // значение по ключу
.has() // проверка на наличие ключа
.delete() // удаление по ключу
.clear() // очищение
.size // количество ключей
.keys() // итерируемый объект по ключам
.values() // итерируемый объект по значениям
.entries() // итерируемый объект ключ/значение

Set
new Set() // создаёт Set (аргумент - итерируемый объект - копирует его значения в новый Set)
.add() // добавляет значение, возвращает тот же объект set.
.delete() // удаляет значение (возвращает true, если значение было)
.has() // проверка на наличие значения
.clear() // очищение
.size // количество значений
.keys() // итерируемый объект по значениям
.values() // итерируемый объект по значениям (совместим с Мар)
.entries() // итерируемый объект ключ/значение

WeakMap // ключ - объект, исчезает при удалении объекта
.set(, ) // запись ключ/значение
.get() // значение по ключу
.has() // проверка на наличие ключа
.delete() // удаление по ключу

WeakSet // ключ - объект, исчезает при удалении объекта
add() // добавляет значение, возвращает тот же объект set.
.delete() // удаляет значение (возвращает true, если значение было)
.has() // проверка на наличие значения

Символы
.description // вывод имени символа объекта
Symbol() // неглобальный символ, игнорируется перебором в объекте через цикл
Symbol.for() // получение символа по имени (или создания) для повторной одинаковой записи
Symbol.keyFor() // получение имени по символу

Преобразования
Number() // преобразование в число (как и +)
String() // преобразование в строку
Boolean() // преобразование в bool (как и !!)
BigInt() // создание целого числа неограниченой длины
typeof() // показать тип переменной

try/catch()/finally // переменные внутри - локальны
.name // имя ошибки, посланное в catch() (если просто так, то "name: message")
.message // текст ошибки, посланный в catch()
.stack // порядок выполнения возникшей ошибки
new Error() // генерация ошибки
new SyntaxError() // генерация ошибки
new ReferenceError() // генерация ошибки
finally // часть кода выполняется после ошибки

Промисы
new Promise(function(resolve, reject) // генерация, resolve() - результат, reject() - ошибка (колбэки)
.then(, ) // аргументы - функции, результата и ошибки
.catch() // обработка только ошибки
.finally() // выполнение функции независимо от результата или ошибки (нет аргумента)
Promise.all() // принимает массив промисов для параллельного выполнение, возвращает массив результатов
Promise.allSettled() // возвращает все значения и ошибки массивом [{status: "", value: {}}, {status: "", reason: {}}, ...]
Promise.all() // возвращает результат самого быстрого промиса
Promise.resolve() // создание промиса с результатом
Promise.reject() // создание промиса с ошибкой

Модули // всегда используют use strict
export // пометка используемой функции для импорта
import {} from "./.js" // импорт функции в директории
import * as ... from "./.js" // импортируется всё сразу
import {... as ...} from "./.js" // импорт с переименованием
export {... as ...} // экспорт с переименованием
export default // экспорт по умолчанию (только один), импорт без {}
let {} = await import("./.js") // динамический импорт, возвращает промис, где результат - объект из экспортов модуля
<script type="module"></script> // явное указание модуля

Матика
Math.floor() // округление вниз
Math.ceil() // округление вверх
Math.round() // математическое округление
Math.trunc() // удаление дробной части
Math.random() // десятичное число: 0 <= n < 1
Math.max() // максимальное из чисел
Math.min() // минимальное из чисел
Math.pow(, ) // число в степени (как и **)
Math.abs() // модуль
Math.cbrt() // кубический корень
Math.exp() // экспонента
Math.log() // ln()
Math.log2() // log2()
Math.log10() // log10()
Math.sign() // в зависимости от знака числа: -1, 0, 1
Math.sqrt() // квадратный корень
Math.E // е
Math.PI // пи

Механика
0.1 + 0.2 != 0.3 // точность - ебанутая штука
(6.35).toFixed(1) != 6.4 // внимательней!
$, _ // допустимые имена переменных
12345n // целое число неограниченой длины (иначе точность 2^52), с другими не смешивается
+"n" // n
n + "m" // "nm"
NaN != NaN
===, !== // строгое сравнение без приведения типов
alert(3 || 4) // 1, возвращает первое истенное значение
undefined // тип неприсвоенной переменной
null // тип пустой переменной
"6" / "2" // 3
Boolean("") // false
Number(undefined) // NaN
a = b = c // a == c
String, Array, Object, Number, Boolean, Function // при изменении их свойств меняется всё